<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/webp" sizes="32x32" href="media-webp/logo/Logo32x32.webp">
    <link rel="icon" type="image/webp" sizes="64x64" href="media-webp/logo/Logo64x64.webp">
    <link rel="apple-touch-icon" sizes="180x180" href="media-webp/logo/Logo180x180.webp">
    <link rel="manifest" href="manifest.json">
    <title data-lang="pdf.meta.title">AI Designer | Stagify.ai</title>
    <meta name="description" data-lang-attr="pdf.meta.description|content" content="Chat with AI Designer to get help with design questions, upload files for analysis, and get professional design advice instantly.">
    
    <!-- SEO Meta Tags -->
    <meta name="robots" content="index, follow">
    <meta name="keywords" data-lang-attr="pdf.meta.keywords|content" content="AI Designer, AI design assistant, design consultation, AI chat, design help, interior design AI, room staging AI, virtual staging assistant, AI interior designer">
    
    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="AI Designer | Stagify.ai - AI-Powered Design Assistant">
    <meta property="og:description" content="Chat with AI Designer to get help with design questions, upload files for analysis, and get professional design advice instantly.">
    <meta property="og:url" content="https://stagify.ai/ai-designer.html">
    <meta property="og:site_name" content="Stagify.ai">
    <meta property="og:image" content="https://stagify.ai/media-webp/logo/Logo180x180.webp">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="AI Designer | Stagify.ai - AI-Powered Design Assistant">
    <meta name="twitter:description" content="Chat with AI Designer to get help with design questions, upload files for analysis, and get professional design advice instantly.">
    <meta name="twitter:image" content="https://stagify.ai/media-webp/logo/Logo180x180.webp">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://stagify.ai/ai-designer.html">
    
    <!-- Hreflang Tags for Multi-language Support -->
    <link rel="alternate" hreflang="en" href="https://stagify.ai/ai-designer.html">
    <link rel="alternate" hreflang="es" href="https://stagify.ai/ai-designer.html">
    <link rel="alternate" hreflang="zh" href="https://stagify.ai/ai-designer.html">
    <link rel="alternate" hreflang="x-default" href="https://stagify.ai/ai-designer.html">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "AI Designer - Stagify.ai",
      "description": "AI-powered design assistant for room staging and interior design. Chat with AI to get design advice, upload images for staging, and receive professional design recommendations.",
      "url": "https://stagify.ai/ai-designer.html",
      "applicationCategory": "DesignApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "creator": {
        "@type": "Organization",
        "name": "Stagify.ai"
      },
      "featureList": [
        "AI-powered design consultation",
        "Image upload and analysis",
        "Room staging assistance",
        "Interior design advice",
        "Real-time chat interface"
      ],
      "keywords": "AI Designer, AI design assistant, design consultation, AI chat, design help, interior design AI, room staging AI"
    }
    </script>
    
    <link rel="stylesheet" href="styles/styles.css">
    <link rel="preload" href="languages/english.json" as="fetch" crossorigin>
    <script src="scripts/language-loader.js" defer></script>
    <style>
      /* Beta badge styling */
      .beta-badge {
        display: inline-block;
        background: linear-gradient(135deg, #991b1b 0%, #7f1d1d 50%, #5c1a1a 100%);
        border-radius: 6px;
        padding: 1px 8px;
        margin-right: 6px;
        box-shadow: 0 2px 4px rgba(153, 27, 27, 0.4);
      }
      
      .beta-badge em {
        font-style: italic;
        color: white;
        font-size: 0.85em;
        font-weight: 600;
      }
      
      /* Prevent horizontal scrolling */
      html, body {
        overflow-x: hidden;
        max-width: 100vw;
      }
      
      /* Ensure hero section doesn't constrain chat container */
      section.hero {
        max-width: 100% !important;
        width: 100% !important;
        padding: 20px !important;
        box-sizing: border-box;
      }
      
      .chat-container {
        width: 100%;
        max-width: 1400px;
        min-width: min(100%, 1400px);
        margin: 0 auto;
        height: calc(100vh - 120px);
        max-height: calc(100vh - 120px);
        display: flex;
        flex-direction: column;
        padding: 20px;
        box-sizing: border-box;
        flex-shrink: 0;
        position: relative;
        overflow: hidden;
      }
      
      .chat-input-container {
        max-width: 900px;
        margin: 0 auto;
        width: 100%;
      }
      
      .chat-messages {
        flex: 1 1 auto;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 20px;
        background: rgba(255, 255, 255, 0.4);
        border-radius: 12px;
        backdrop-filter: blur(10px);
        border: 1px solid var(--border);
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-width: 0;
        width: 100%;
        min-height: 0;
        transition: border-color 0.2s, background 0.2s;
      }
      
      /* Drag and drop styles */
      .chat-messages.drag-over {
        border: 2px dashed #2563eb;
        background: rgba(37, 99, 235, 0.1);
      }
      
      /* Drop files message - centered when shown on drag */
      .chat-container::before {
        content: 'Drop files here to upload';
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(37, 99, 235, 0.9);
        color: white;
        padding: 20px 40px;
        border-radius: 12px;
        font-size: 18px;
        font-weight: 600;
        z-index: 100;
        pointer-events: none;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        opacity: 0;
        transition: opacity 0.2s ease-in;
      }
      
      .chat-container.drag-over::before {
        opacity: 1;
      }
      
      .message {
        display: flex;
        gap: 12px;
        animation: fadeIn 0.3s ease-in;
        min-width: 0;
        width: 100%;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .message.user {
        flex-direction: row-reverse;
      }
      
      .message-avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        flex-shrink: 0;
      }
      
      .message.user .message-avatar {
        width: 36px;
        height: 36px;
        align-self: flex-start;
        margin-top: 0;
      }
      
      .message.user .message-avatar {
        background: #2563eb;
        padding: 0;
        overflow: hidden;
      }
      
      .message.user .message-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
      }
      
      .message.assistant .message-avatar {
        background: transparent;
        color: white;
        padding: 0;
        overflow: hidden;
      }
      
      .message.assistant .message-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
      }
      
      .message-content {
        padding: 12px 16px;
        border-radius: 12px;
        max-width: min(80%, 800px);
        word-wrap: break-word;
        overflow-wrap: break-word;
        min-width: 0;
        box-sizing: border-box;
      }
      
      .message.assistant .message-content {
        white-space: pre-wrap;
      }
      
      .message.assistant .message-content strong {
        font-weight: 600;
      }
      
      .message.assistant .message-content ul,
      .message.assistant .message-content ol {
        margin: 8px 0;
        padding-left: 24px;
      }
      
      .message.assistant .message-content li {
        margin: 4px 0;
      }
      
      .message.user .message-content {
        background: #2563eb;
        color: white;
        border-bottom-right-radius: 4px;
      }
      
      .message.assistant .message-content {
        background: rgba(255, 255, 255, 0.8);
        color: #1e3a8a;
        border-bottom-left-radius: 4px;
      }
      
      .message-file {
        margin-top: 8px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 6px;
        font-size: 0.9rem;
        display: inline-block;
        box-sizing: border-box;
        max-width: 100%;
      }
      
      .message-file img {
        max-width: min(400px, 100%);
        max-height: 300px;
        border-radius: 4px;
        height: auto;
        width: auto;
        display: block;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        cursor: pointer;
        transition: opacity 0.2s, transform 0.2s;
      }
      
      .message-file img:hover {
        opacity: 0.9;
        transform: scale(1.02);
      }
      
      .message-file a {
        color: inherit;
        text-decoration: underline;
      }
      
      .chat-input-container {
        display: flex;
        flex-direction: column;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 24px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(37, 99, 235, 0.2);
        padding: 8px 16px 12px 16px;
        min-width: 0;
        box-sizing: border-box;
        flex-shrink: 0;
        box-shadow: 0 2px 8px rgba(37, 99, 235, 0.1);
        max-width: 900px;
        margin: 0 auto;
        width: 100%;
      }
      
      .file-preview-container {
        display: none;
        padding: 8px 0;
        border-bottom: 1px solid rgba(37, 99, 235, 0.2);
        margin-bottom: 8px;
      }
      
      .file-preview-container.has-files {
        display: block;
      }
      
      .file-preview-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      
      .file-preview-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        background: rgba(37, 99, 235, 0.1);
        border-radius: 6px;
        font-size: 14px;
        max-width: 100%;
        min-width: 0;
        box-sizing: border-box;
        color: #1e3a8a;
      }
      
      .file-preview-item img {
        width: 40px;
        height: 40px;
        object-fit: cover;
        border-radius: 4px;
      }
      
      .file-preview-item .file-info {
        flex: 1;
        min-width: 0;
      }
      
      .file-preview-item .file-name {
        font-weight: 500;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      
      .file-preview-item .file-size {
        font-size: 12px;
        color: #6b7280;
      }
      
      .file-preview-item .file-remove {
        background: none;
        border: none;
        color: #ef4444;
        cursor: pointer;
        padding: 4px;
        font-size: 18px;
        line-height: 1;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      
      .file-preview-item .file-remove:hover {
        opacity: 1;
      }
      
      .chat-input-row {
        display: flex;
        align-items: flex-end;
        gap: 8px;
        min-width: 0;
        width: 100%;
        position: relative;
      }
      
      .input-bottom-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        position: absolute;
        bottom: 0;
        left: 2px;
        padding-bottom: 4px;
        z-index: 10;
        pointer-events: auto;
      }
      
      .reload-btn {
        padding: 8px;
        background: transparent;
        color: #2563eb;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s, color 0.2s;
        height: 36px;
        width: 36px;
        flex-shrink: 0;
        position: relative;
        z-index: 11;
        pointer-events: auto;
      }
      
      .reload-btn img {
        filter: brightness(0) saturate(100%) invert(27%) sepia(95%) saturate(2598%) hue-rotate(212deg) brightness(99%) contrast(96%);
        width: 20px !important;
        height: 20px !important;
        object-fit: contain;
        transition: filter 0.2s;
      }
      
      .reload-btn:hover {
        background: rgba(37, 99, 235, 0.1);
      }
      
      .reload-btn:hover img {
        filter: brightness(0) saturate(100%) invert(27%) sepia(95%) saturate(2598%) hue-rotate(212deg) brightness(110%) contrast(96%);
      }
      
      .file-upload-btn {
        padding: 8px;
        background: transparent;
        color: #2563eb;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
        height: 36px;
        width: 36px;
        flex-shrink: 0;
        position: relative;
        z-index: 11;
        pointer-events: auto;
      }
      
      .file-upload-btn img {
        filter: brightness(0) saturate(100%) invert(27%) sepia(95%) saturate(2598%) hue-rotate(212deg) brightness(99%) contrast(96%);
        width: 20px !important;
        height: 20px !important;
        object-fit: contain;
        transition: filter 0.2s;
      }
      
      .file-upload-btn:hover {
        background: rgba(37, 99, 235, 0.1);
      }
      
      .file-upload-btn:hover img {
        filter: brightness(0) saturate(100%) invert(27%) sepia(95%) saturate(2598%) hue-rotate(212deg) brightness(110%) contrast(96%);
      }
      
      .file-upload-btn input {
        display: none;
      }
      
      .chat-input-wrapper {
        flex: 1;
        position: relative;
        display: flex;
        align-items: center;
        margin-left: 0;
        margin-bottom: 40px;
        margin-top: -5px;
      }
      
      .chat-input-wrapper::before {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 56px;
        height: 40px;
        z-index: 5;
        pointer-events: none;
      }
      
      .chat-input {
        width: 100%;
        padding: 12px 16px 12px 8px;
        border: none;
        border-radius: 0;
        font-size: 16px;
        font-family: inherit;
        resize: none;
        min-height: 48px;
        max-height: 50px;
        background: transparent;
        color: #1e3a8a;
        line-height: 1.5;
        box-sizing: border-box;
        overflow-y: auto;
        overflow-x: hidden;
        margin: 0;
      }
      
      .chat-input::placeholder {
        color: #6b7280;
      }
      
      .chat-input:focus {
        outline: none;
      }
      
      .chat-input.multi-line {
        overflow-y: auto;
      }
      
      .send-btn {
        padding: 8px;
        background: transparent;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.2s;
        height: 48px;
        width: 48px;
        flex-shrink: 0;
        position: absolute;
        bottom: 32px;
        right: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .send-btn img {
        width: 30px !important;
        height: 30px !important;
        object-fit: contain;
        transition: filter 0.2s;
      }
      
      .send-btn:not(:disabled) img {
        filter: brightness(0) saturate(100%) invert(27%) sepia(95%) saturate(2598%) hue-rotate(212deg) brightness(99%) contrast(96%);
      }
      
      .send-btn:hover:not(:disabled) {
        background: rgba(37, 99, 235, 0.1);
      }
      
      .send-btn:hover:not(:disabled) img {
        filter: brightness(0) saturate(100%) invert(27%) sepia(95%) saturate(2598%) hue-rotate(212deg) brightness(110%) contrast(96%);
      }
      
      .send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      .send-btn:disabled img {
        filter: brightness(0) invert(0.4);
      }
      
      .send-controls {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 8px;
        flex-shrink: 0;
        position: relative;
      }
      
      .model-selector {
        position: relative;
      }
      
      .model-selector-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 6px 10px;
        background: transparent;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
        color: #1e3a8a;
        font-size: 14px;
        font-weight: 500;
      }
      
      .model-selector-btn:hover {
        background: rgba(37, 99, 235, 0.1);
      }
      
      .model-selector-text {
        color: #1e3a8a;
        font-weight: bold;
        font-family: inherit;
      }
      
      .model-selector-chevron {
        color: #1e3a8a;
        transition: transform 0.2s;
      }
      
      .model-selector.open .model-selector-chevron {
        transform: rotate(180deg);
      }
      
      .model-dropdown {
        position: absolute;
        bottom: calc(100% + 8px);
        right: 0;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(37, 99, 235, 0.2);
        border-radius: 12px;
        box-shadow: 0 4px 16px rgba(37, 99, 235, 0.15);
        min-width: 200px;
        padding: 8px;
        display: none;
        z-index: 1000;
        backdrop-filter: blur(10px);
      }
      
      .model-selector.open .model-dropdown {
        display: block;
      }
      
      .model-dropdown-header {
        padding: 12px 16px 8px 16px;
        color: #6b7280;
        font-size: 12px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .model-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.2s;
      }
      
      .model-option:hover {
        background: rgba(37, 99, 235, 0.1);
      }
      
      .model-option-content {
        flex: 1;
      }
      
      .model-option-name {
        color: #1e3a8a;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 4px;
      }
      
      .model-option-description {
        color: #6b7280;
        font-size: 12px;
      }
      
      .model-badge {
        background: #2563eb;
        color: white;
        font-size: 10px;
        font-weight: 600;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 12px;
      }
      
      .typing-indicator {
        padding: 12px 16px;
        color: #6b7280;
        font-style: italic;
      }
      
      .empty-state {
        text-align: center;
        color: #6b7280;
        padding: 40px 20px;
        width: 100%;
        box-sizing: border-box;
      }
      
      .empty-state h3 {
        color: #1e3a8a;
        margin-bottom: 8px;
      }
      
      /* AI-generated image container - relative positioning for download button */
      .ai-image-container {
        position: relative;
        display: inline-block;
        max-width: 100%;
      }
      
      /* AI-generated image styles - smaller by default, clickable */
      .ai-generated-image {
        max-width: 100%;
        max-height: 300px;
        border-radius: 8px;
        display: block;
        margin: 0;
        width: auto;
        height: auto;
        box-sizing: border-box;
        cursor: pointer;
        transition: transform 0.2s, opacity 0.2s;
        transform-origin: center;
      }
      
      /* Scale image when hovering over container (image or button) */
      .ai-image-container:hover .ai-generated-image {
        opacity: 0.9;
        transform: scale(1.02);
      }
      
      /* Download button for AI-generated images */
      .ai-image-download-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.7);
        border: none;
        border-radius: 6px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s, transform 0.2s;
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        padding: 0;
        transform-origin: center;
      }
      
      .ai-image-download-btn img {
        width: 20px;
        height: 20px;
        object-fit: contain;
        filter: brightness(0) invert(1);
      }
      
      .ai-image-download-btn:hover {
        background: rgba(0, 0, 0, 0.9);
        transform: scale(1.1);
      }
      
      .ai-image-download-btn:active {
        transform: scale(0.95);
      }
      
      /* Move download button to maintain distance from edge when image scales */
      /* When image scales by 1.02 from center, the top-right corner moves outward */
      /* For a typical 300px image: corner moves by ~1.5px (half of 3px increase) */
      /* We use a small fixed value that works well for most image sizes */
      .ai-image-container:hover .ai-image-download-btn {
        transform: translate(1.5px, -1.5px);
      }
      
      .ai-image-container:hover .ai-image-download-btn:hover {
        transform: translate(1.5px, -1.5px) scale(1.1);
      }
      
      .ai-image-container:hover .ai-image-download-btn:active {
        transform: translate(1.5px, -1.5px) scale(0.95);
      }
      
      /* Image modal/lightbox */
      .image-modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(5px);
        animation: fadeIn 0.3s ease-in;
        cursor: pointer;
      }
      
      .image-modal.active {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .image-modal-content {
        max-width: 95%;
        max-height: 95%;
        width: auto;
        height: auto;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        animation: zoomIn 0.3s ease-in;
        cursor: default;
      }
      
      @keyframes zoomIn {
        from { transform: scale(0.8); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
      }
      
      .image-modal-close {
        position: absolute;
        top: 20px;
        right: 30px;
        color: white;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        z-index: 10001;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 50%;
        transition: background 0.2s;
      }
      
      .image-modal-close:hover {
        background: rgba(0, 0, 0, 0.8);
      }
      
      @media (max-width: 768px) {
        .chat-container {
          height: calc(100vh - 100px);
          padding: 10px;
        }
        
        .message-content {
          max-width: 85%;
        }
        
        .chat-input-container {
          padding: 12px;
        }
        
        .file-preview-item {
          max-width: 100%;
        }
      }
      
      /* Custom Stagify Scrollbar */
      * {
        scrollbar-width: thin;
        scrollbar-color: #2563eb rgba(255, 255, 255, 0.2);
      }
      
      *::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      
      *::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
      }
      
      *::-webkit-scrollbar-thumb {
        background: #2563eb;
        border-radius: 10px;
        border: 2px solid transparent;
        background-clip: padding-box;
      }
      
      *::-webkit-scrollbar-thumb:hover {
        background: #1d4ed8;
        background-clip: padding-box;
      }
    </style>
  </head>
  <body>
    <!-- Background Video -->
    <video id="background-video" autoplay muted loop playsinline webkit-playsinline preload="auto">
      <source src="background.mp4" type="video/mp4">
    </video>

    <header class="site-header">
      <nav class="nav">
        <div class="brand"><img src="media-webp/logo/Logo64x64.webp" alt="Stagify.ai Logo" class="brand-logo" fetchpriority="high"><span class="brand-strong">stagify</span><span class="brand-light">.ai</span></div>
        <div class="nav-center">
          <a href="index.html" class="nav-link" data-lang="navigation.home">Home</a>
          <a href="ai-designer.html" class="nav-link desktop-only" data-lang-html="navigation.pdfTo3d">AI Designer</a>
          <a href="why.html#why" class="nav-link" data-lang="navigation.whyUs">Why Us?</a>
          <a href="faq.html#faq" class="nav-link" data-lang="navigation.faq">FAQ</a>
          <a href="contact.html#contact" class="nav-link" data-lang="navigation.contactUs">Contact Us</a>
        </div>
        <div class="mobile-test-text">
          <div data-lang="hero.title.upload">Upload.</div>
          <div data-lang="hero.title.stage">Stage.</div>
          <div data-lang="hero.title.imagine">Imagine.</div>
        </div>
      </nav>
    </header>

    <main>
      <div class="language-picker-container">
        <div class="language-selector">
          <label for="language-select" class="sr-only">Select language</label>
          <select id="language-select" class="language-dropdown">
            <option value="english" selected>EN</option>
            <option value="spanish">ES</option>
            <option value="chinese">中文</option>
          </select>
        </div>
      </div>

      <section class="hero" style="grid-template-columns: 1fr; padding: 20px; width: 100%; max-width: 100%; box-sizing: border-box;">
        <div class="chat-container">
          <div class="chat-messages" id="chat-messages">
            <div class="empty-state">
              <h3 data-lang="pdf.title">AI Designer</h3>
              <p data-lang="pdf.emptyState">Start a conversation by typing a message or uploading a file</p>
            </div>
          </div>
          
          <div class="chat-input-container">
            <div class="file-preview-container" id="file-preview-container">
              <div class="file-preview-list" id="file-preview-list"></div>
            </div>
            
            <div class="chat-input-row">
              <div class="input-bottom-controls">
                <label class="file-upload-btn" data-lang-attr="pdf.uploadFile|title" title="Upload file">
                  <img src="media-webp/file.webp" alt="Upload file">
                  <input type="file" id="file-input" multiple accept="image/*,.pdf,.txt,.doc,.docx,.jpg,.jpeg">
                </label>
                
                <button class="reload-btn" id="reload-btn" title="Reload chat">
                  <img src="media-webp/Reload.webp" alt="Reload chat">
                </button>
              </div>
              
              <div class="chat-input-wrapper">
                <textarea 
                  id="chat-input" 
                  class="chat-input" 
                  data-lang="pdf.inputPlaceholder"
                  placeholder="Type your message..."
                  rows="1"
                  maxlength="5000"
                ></textarea>
              </div>
              
              <div class="send-controls">
                <button id="send-btn" class="send-btn" title="Send message">
                  <img src="media-webp/Send.webp" alt="Send">
                </button>
                <div class="model-selector">
                  <button class="model-selector-btn" id="model-selector-btn">
                    <span class="model-selector-text">Fast</span>
                    <svg class="model-selector-chevron" width="16" height="16" viewBox="0 0 16 16" fill="none">
                      <path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                  </button>
                  <div class="model-dropdown" id="model-dropdown">
                    <div class="model-dropdown-header" data-lang="pdf.modelSelector.chooseModel">Choose your model</div>
                    <div class="model-option" data-model="fast">
                      <div class="model-option-content">
                        <div class="model-option-name" data-lang="pdf.modelSelector.fast">Fast</div>
                        <div class="model-option-description" data-lang="pdf.modelSelector.fastDescription">Standard quality, faster</div>
                      </div>
                    </div>
                    <div class="model-option" data-model="pro">
                      <div class="model-option-content">
                        <div class="model-option-name" data-lang="pdf.modelSelector.pro">Pro</div>
                        <div class="model-option-description" data-lang="pdf.modelSelector.proDescription">Higher quality, slower</div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <script>
      const chatMessages = document.getElementById('chat-messages');
      const chatInput = document.getElementById('chat-input');
      const sendBtn = document.getElementById('send-btn');
      const fileInput = document.getElementById('file-input');
      const chatContainer = document.querySelector('.chat-container');
      
      let conversationHistory = [];
      let selectedFiles = [];
      let isProcessing = false; // Track if we're currently processing a message
      let dragCounter = 0; // Track drag enter/leave events to handle nested elements
      
      // Load welcome message on page load
      async function loadWelcomeMessage() {
        try {
          // Remove empty state immediately
          const emptyState = chatMessages.querySelector('.empty-state');
          if (emptyState) {
            emptyState.remove();
          }
          
          // Show typing indicator while loading welcome message
          const typingId = showTypingIndicator('welcome');
          
          // Generate a simple user ID (you can enhance this with actual user identification)
          const userId = localStorage.getItem('userId') || `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem('userId', userId);
          
          const response = await fetch(`/api/welcome-message?userId=${encodeURIComponent(userId)}`);
          const data = await response.json();
          
          // Remove typing indicator
          removeTypingIndicator(typingId);
          
          if (data.message) {
            // Add welcome message
            addMessage('assistant', data.message);
            
            // Add to conversation history
            conversationHistory.push({ role: 'assistant', content: data.message });
          }
        } catch (error) {
          console.error('Error loading welcome message:', error);
          // Remove typing indicator if it exists
          const typingIndicator = document.getElementById('typing-indicator');
          if (typingIndicator) {
            typingIndicator.remove();
          }
          // If welcome message fails, just remove empty state (already removed above)
        }
      }
      
      // Load welcome message when page loads
      loadWelcomeMessage();
      
      // Reload button functionality
      const reloadBtn = document.getElementById('reload-btn');
      reloadBtn.addEventListener('click', function() {
        // Reset conversation history
        conversationHistory = [];
        
        // Clear chat messages
        chatMessages.innerHTML = '';
        
        // Clear file selection
        selectedFiles = [];
        updateFilePreview();
        
        // Clear input
        chatInput.value = '';
        
        // Reset processing state
        isProcessing = false;
        updateSendButtonState();
        
        // Load welcome message (same as page load)
        loadWelcomeMessage();
      });
      
      // Format file size
      function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
      }
      
      // Update file preview
      function updateFilePreview() {
        const container = document.getElementById('file-preview-container');
        const list = document.getElementById('file-preview-list');
        
        if (selectedFiles.length === 0) {
          container.classList.remove('has-files');
          list.innerHTML = '';
          return;
        }
        
        container.classList.add('has-files');
        list.innerHTML = '';
        
        selectedFiles.forEach((file, index) => {
          const item = document.createElement('div');
          item.className = 'file-preview-item';
          
          if (file.type.startsWith('image/')) {
            const img = document.createElement('img');
            img.src = URL.createObjectURL(file);
            img.alt = file.name;
            item.appendChild(img);
          } else {
            const icon = document.createElement('div');
            icon.style.cssText = 'width: 40px; height: 40px; background: #2563eb; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;';
            icon.textContent = file.name.split('.').pop().toUpperCase().substring(0, 3);
            item.appendChild(icon);
          }
          
          const fileInfo = document.createElement('div');
          fileInfo.className = 'file-info';
          
          const fileName = document.createElement('div');
          fileName.className = 'file-name';
          fileName.textContent = file.name;
          
          const fileSize = document.createElement('div');
          fileSize.className = 'file-size';
          fileSize.textContent = formatFileSize(file.size);
          
          fileInfo.appendChild(fileName);
          fileInfo.appendChild(fileSize);
          item.appendChild(fileInfo);
          
          const removeBtn = document.createElement('button');
          removeBtn.className = 'file-remove';
          removeBtn.innerHTML = '×';
          removeBtn.onclick = () => {
            selectedFiles.splice(index, 1);
            updateFilePreview();
          };
          item.appendChild(removeBtn);
          
          list.appendChild(item);
        });
      }
      
      // Format markdown text to HTML
      function formatMarkdown(text) {
        if (!text) return '';
        
        // Split into lines for processing
        const lines = text.split('\n');
        let html = '';
        let inList = false;
        
        lines.forEach((line, index) => {
          // Check for bullet points: * item, - item, or • item
          const bulletMatch = line.match(/^[\*\-\+•]\s+(.+)$/);
          
          if (bulletMatch) {
            if (!inList) {
              html += '<ul>';
              inList = true;
            }
            let itemText = bulletMatch[1];
            // Process bold and italic within list items
            itemText = itemText.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            itemText = itemText.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
            html += `<li>${itemText}</li>`;
          } else {
            if (inList) {
              html += '</ul>';
              inList = false;
            }
            
            if (line.trim()) {
              // Process bold and italic in regular lines
              let processedLine = line
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                .replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
              html += processedLine;
            }
            
            // Add line break if not last line
            if (index < lines.length - 1) {
              html += '<br>';
            }
          }
        });
        
        if (inList) {
          html += '</ul>';
        }
        
        return html;
      }
      
      // Handle input (fixed height, no auto-resize)
      chatInput.addEventListener('input', function() {
        // Enforce character limit (maxlength should handle this, but just in case)
        if (this.value.length > 5000) {
          this.value = this.value.substring(0, 5000);
        }
        
        // Show scrollbar only if content exceeds one line
        if (this.scrollHeight > 48) {
          this.classList.add('multi-line');
        } else {
          this.classList.remove('multi-line');
        }
        
        if (!isProcessing) {
          updateSendButtonState();
        }
      });
      
      // Check on focus to show scrollbar if needed
      chatInput.addEventListener('focus', function() {
        if (this.scrollHeight > 48) {
          this.classList.add('multi-line');
        }
      });
      
      // Hide scrollbar when not focused if content fits in one line
      chatInput.addEventListener('blur', function() {
        if (this.scrollHeight <= 48) {
          this.classList.remove('multi-line');
        }
      });
      
      // Send message on Enter (Shift+Enter for new line)
      chatInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          // Only send if not currently processing and send button is enabled
          if (!isProcessing && !sendBtn.disabled) {
            sendMessage();
          }
        }
      });
      
      // Send button click
      sendBtn.addEventListener('click', sendMessage);
      
      // Helper function to handle files (used by both file input and drag & drop)
      function handleFiles(files) {
        // Filter files to only accept the same types as the file input
        const acceptedTypes = ['image/', '.pdf', '.txt', '.doc', '.docx', '.jpg', '.jpeg'];
        const filteredFiles = Array.from(files).filter(file => {
          return acceptedTypes.some(type => 
            file.type.startsWith(type) || 
            file.name.toLowerCase().endsWith(type.replace('.', '.'))
          );
        });
        
        if (filteredFiles.length > 0) {
          // Check how many files can still be added (max 3 total)
          const remainingSlots = 3 - selectedFiles.length;
          if (remainingSlots > 0) {
            const filesToAdd = filteredFiles.slice(0, remainingSlots);
            selectedFiles.push(...filesToAdd);
            updateFilePreview();
            if (!isProcessing) {
              updateSendButtonState();
            }
            
            // Show message if user tried to add more than allowed
            if (filteredFiles.length > remainingSlots) {
              const excessCount = filteredFiles.length - remainingSlots;
              alert(`Maximum of 3 files allowed. Only ${remainingSlots} file(s) added. ${excessCount} file(s) were not added.`);
            }
          } else {
            alert('Maximum of 3 files allowed. Please remove some files before adding more.');
          }
        }
      }
      
      // File upload - add to preview instead of uploading immediately
      fileInput.addEventListener('change', function(e) {
        const files = Array.from(e.target.files);
        handleFiles(files);
        e.target.value = ''; // Reset input
      });
      
      // Drag and drop functionality
      chatMessages.addEventListener('dragenter', function(e) {
        e.preventDefault();
        e.stopPropagation();
        dragCounter++;
        if (e.dataTransfer.types.includes('Files')) {
          chatMessages.classList.add('drag-over');
          chatContainer.classList.add('drag-over');
        }
      });
      
      chatMessages.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        if (e.dataTransfer.types.includes('Files')) {
          e.dataTransfer.dropEffect = 'copy';
        }
      });
      
      chatMessages.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        dragCounter--;
        if (dragCounter === 0) {
          chatMessages.classList.remove('drag-over');
          chatContainer.classList.remove('drag-over');
        }
      });
      
      chatMessages.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        dragCounter = 0;
        chatMessages.classList.remove('drag-over');
        chatContainer.classList.remove('drag-over');
        
        const files = Array.from(e.dataTransfer.files);
        if (files.length > 0) {
          handleFiles(files);
        }
      });
      
      // Also handle drag and drop on the chat container for better coverage
      chatContainer.addEventListener('dragenter', function(e) {
        e.preventDefault();
        e.stopPropagation();
        if (e.dataTransfer.types.includes('Files')) {
          dragCounter++;
          chatMessages.classList.add('drag-over');
          chatContainer.classList.add('drag-over');
        }
      });
      
      chatContainer.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        if (e.dataTransfer.types.includes('Files')) {
          e.dataTransfer.dropEffect = 'copy';
        }
      });
      
      chatContainer.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        // Only remove if we're leaving the container entirely
        if (!chatContainer.contains(e.relatedTarget)) {
          dragCounter = 0;
          chatMessages.classList.remove('drag-over');
          chatContainer.classList.remove('drag-over');
        }
      });
      
      chatContainer.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        dragCounter = 0;
        chatMessages.classList.remove('drag-over');
        chatContainer.classList.remove('drag-over');
        
        const files = Array.from(e.dataTransfer.files);
        if (files.length > 0) {
          handleFiles(files);
        }
      });
      
      // Initialize send button state
      updateSendButtonState();
      
      function sendMessage() {
        const message = chatInput.value.trim();
        if (!message && selectedFiles.length === 0) return;
        
        // Show user message in chat
        const userMessageText = message || (selectedFiles.length > 0 ? `Uploaded ${selectedFiles.length} file(s)` : '');
        if (userMessageText) {
          addMessage('user', userMessageText, selectedFiles);
        }
        
        // Clear input and files
        chatInput.value = '';
        const filesToSend = [...selectedFiles];
        selectedFiles = [];
        updateFilePreview();
        
        // Disable send button while processing (but allow typing and file selection)
        isProcessing = true;
        updateSendButtonState();
        
        // Determine message type based on user input
        const messageLower = message.toLowerCase();
        let messageType = 'general';
        if (messageLower.includes('generate') || messageLower.includes('create an image') || messageLower.includes('make an image') || messageLower.includes('draw') || messageLower.includes('show me an image of')) {
          messageType = 'generating';
        } else if (messageLower.includes('stage') || messageLower.includes('design') || messageLower.includes('furniture') || messageLower.includes('decorate')) {
          messageType = 'staging';
        } else if (messageLower.includes('describe') || messageLower.includes('analyze') || messageLower.includes('look at') || messageLower.includes('show me') || (messageLower.includes('image') && (messageLower.includes('how') || messageLower.includes('what')))) {
          messageType = 'analyzing';
        }
        
        // Show typing indicator
        const typingId = showTypingIndicator(messageType);
        
        // Store images in conversation history and send
        const userMessageContent = [];
        if (message && message.trim()) {
          userMessageContent.push({ type: 'text', text: message });
        }
        
        // Convert files to base64 and store in conversation history
        const filePromises = filesToSend.map(file => {
          return new Promise((resolve) => {
            if (file.type.startsWith('image/')) {
              const reader = new FileReader();
              reader.onload = (e) => {
                userMessageContent.push({
                  type: 'image_url',
                  image_url: { url: e.target.result },
                  filename: file.name // Store filename for annotation matching
                });
                resolve();
              };
              reader.readAsDataURL(file);
            } else {
              // For non-image files, just store the filename
              userMessageContent.push({
                type: 'text',
                text: `[File: ${file.name}]`
              });
              resolve();
            }
          });
        });
        
        // Wait for all files to be read, then send
        Promise.all(filePromises).then(() => {
          // Add user message to conversation history (avoid duplicates)
          const userMessage = { 
            role: 'user', 
            content: userMessageContent.length > 0 ? userMessageContent : userMessageText
          };
          
          // Check if the last message is the same (avoid duplicates)
          const lastMessage = conversationHistory[conversationHistory.length - 1];
          const isDuplicate = lastMessage && 
            lastMessage.role === 'user' && 
            JSON.stringify(lastMessage.content) === JSON.stringify(userMessage.content);
          
          if (!isDuplicate) {
            conversationHistory.push(userMessage);
          }
          
          // Send to backend
          if (filesToSend.length > 0) {
            // Send with files
            const formData = new FormData();
            filesToSend.forEach(file => {
              formData.append('files', file);
            });
            if (message) {
              formData.append('message', message);
            }
            // Send conversation history so backend can access previous images
            formData.append('conversationHistory', JSON.stringify(conversationHistory));
            
            // Get userId from localStorage
            const userId = localStorage.getItem('userId');
            if (userId) {
              formData.append('userId', userId);
            }
            
            // Add model to formData
            const selectedModel = window.getSelectedModelApiName ? window.getSelectedModelApiName() : 'gpt-4o-mini';
            formData.append('model', selectedModel);
            
            fetch('/api/chat-upload', {
              method: 'POST',
              body: formData,
            })
            .then(response => response.json())
            .then(data => {
              removeTypingIndicator(typingId);
              
              if (data.error) {
                addMessage('assistant', 'Sorry, I encountered an error: ' + data.error);
              } else if (data.contextLimitReached) {
                // Context limit reached - show message and don't add to history
                addMessage('assistant', data.response);
              } else {
                // Update user message in conversation history with annotations if available
                if (data.imageAnnotations && Object.keys(data.imageAnnotations).length > 0) {
                  // Find the last user message in conversation history
                  for (let i = conversationHistory.length - 1; i >= 0; i--) {
                    const msg = conversationHistory[i];
                    if (msg.role === 'user' && Array.isArray(msg.content)) {
                      // Update images with their annotations
                      msg.content.forEach(item => {
                        if (item.type === 'image_url') {
                          // Try to match by filename
                          const filename = item.filename;
                          if (filename && data.imageAnnotations[filename]) {
                            item.annotation = data.imageAnnotations[filename];
                          } else {
                            // Try matching by checking all annotation keys
                            const matchingKey = Object.keys(data.imageAnnotations).find(key => 
                              filename && (filename.includes(key) || key.includes(filename))
                            );
                            if (matchingKey) {
                              item.annotation = data.imageAnnotations[matchingKey];
                            }
                          }
                        }
                      });
                      break;
                    }
                  }
                }
                
                // Handle staged images (single or array)
                const stagedImages = data.stagedImages || (data.stagedImage ? [data.stagedImage] : []);
                if (stagedImages.length > 0) {
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Then add the staged image(s) to the last assistant message
                  const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                  if (lastMessage) {
                    stagedImages.forEach((stagedImage, index) => {
                      const stagedImageDiv = document.createElement('div');
                      stagedImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                      
                      const imageContainer = createAIImageWithDownload(stagedImage, `Staged Room ${stagedImages.length > 1 ? `(${index + 1})` : ''}`, `staged-room-${index}`);
                      stagedImageDiv.appendChild(imageContainer);
                      
                      lastMessage.appendChild(stagedImageDiv);
                    });
                  }
                  
                  // Store staged image(s) in conversation history
                  const contentItems = [{ type: 'text', text: data.response }];
                  stagedImages.forEach((stagedImage, index) => {
                    const annotationKey = stagedImages.length === 1 ? 'staged_0' : `staged_${index}`;
                    const annotation = data.stagedImageAnnotations && data.stagedImageAnnotations[annotationKey] ? data.stagedImageAnnotations[annotationKey] : null;
                    contentItems.push({ 
                      type: 'image_url', 
                      image_url: { url: stagedImage },
                      isStaged: true,
                      _annotation: annotation // Store annotation for backend context building
                    });
                  });
                  
                  const assistantMessage = { 
                    role: 'assistant', 
                    content: contentItems
                  };
                  
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                } else if (data.generatedImages || data.generatedImage) {
                  // If image generation was processed, display the generated image(s)
                  const generatedImages = data.generatedImages || (data.generatedImage ? [data.generatedImage] : []);
                  
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Then add the generated image(s) to the last assistant message
                  const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                  if (lastMessage) {
                    generatedImages.forEach((generatedImage, index) => {
                      const generatedImageDiv = document.createElement('div');
                      generatedImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                      
                      const imageContainer = createAIImageWithDownload(generatedImage, `Generated Image ${generatedImages.length > 1 ? `(${index + 1})` : ''}`, `generated-image-${index}`);
                      generatedImageDiv.appendChild(imageContainer);
                      
                      lastMessage.appendChild(generatedImageDiv);
                    });
                  }
                  
                  // Store generated image(s) in conversation history so they can be accessed later
                  const contentItems = [{ type: 'text', text: data.response }];
                  generatedImages.forEach((generatedImage, index) => {
                    const annotationKey = generatedImages.length === 1 ? 'generated_0' : `generated_${index}`;
                    const annotation = data.generatedImageAnnotations && data.generatedImageAnnotations[annotationKey] ? data.generatedImageAnnotations[annotationKey] : null;
                    contentItems.push({ 
                      type: 'image_url', 
                      image_url: { url: generatedImage },
                      isGenerated: true, // Mark as generated image for backend
                      _annotation: annotation // Store annotation for backend context building
                    });
                  });
                  
                  const assistantMessage = { 
                    role: 'assistant', 
                    content: contentItems
                  };
                  
                  // Check for duplicates
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                } else if (data.cadImage || (data.cadImages && data.cadImages.length > 0)) {
                  // If CAD processing was done, display the CAD image(s)
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Normalize to array
                  const cadImages = data.cadImages || (data.cadImage ? [data.cadImage] : []);
                  
                  if (cadImages.length > 0) {
                    // Then add the CAD image(s) to the last assistant message
                    const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                    if (lastMessage) {
                      cadImages.forEach((cadImage, index) => {
                        const cadImageDiv = document.createElement('div');
                        cadImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                        
                        const imageTitle = cadImages.length > 1 ? `3D Render from Blueprint (${index + 1})` : '3D Render from Blueprint';
                        const imageContainer = createAIImageWithDownload(cadImage, imageTitle, `cad-render-${index}`);
                        cadImageDiv.appendChild(imageContainer);
                        
                        lastMessage.appendChild(cadImageDiv);
                      });
                    }
                    
                    // Store CAD image(s) in conversation history
                    const cadAnnotation = data.cadImageAnnotation || null;
                    const cadAnnotations = data.cadImageAnnotations || {};
                    const cadAssistantMessage = { 
                      role: 'assistant', 
                      content: [
                        { type: 'text', text: data.response },
                        ...cadImages.map((cadImage, index) => ({
                          type: 'image_url', 
                          image_url: { url: cadImage },
                          isGenerated: true, // Mark as generated image for backend
                          _annotation: cadImages.length === 1 ? cadAnnotation : (cadAnnotations[`cad_${index}`] || null) // Store annotation for backend context building
                        }))
                      ]
                    };
                  
                  const lastMsg2 = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate2 = lastMsg2 && 
                    lastMsg2.role === 'assistant' && 
                    JSON.stringify(lastMsg2.content) === JSON.stringify(cadAssistantMessage.content);
                  
                  if (!isDuplicate2) {
                    conversationHistory.push(cadAssistantMessage);
                  }
                  }
                } else if (data.recalledImage) {
                  // If an image was recalled for display, show it
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Then add the recalled image to the last assistant message
                  const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                  if (lastMessage) {
                    const recalledImageDiv = document.createElement('div');
                    recalledImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                    
                    const imageContainer = createAIImageWithDownload(data.recalledImage, 'Recalled Image', 'recalled-image');
                    recalledImageDiv.appendChild(imageContainer);
                    
                    lastMessage.appendChild(recalledImageDiv);
                  }
                  
                  // Store the message in conversation history (don't duplicate the image)
                  const assistantMessage = { 
                    role: 'assistant', 
                    content: data.response
                  };
                  
                  // Check for duplicates
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                } else if (data.recalledImage) {
                  // If an image was recalled for display, show it
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Then add the recalled image to the last assistant message
                  const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                  if (lastMessage) {
                    const recalledImageDiv = document.createElement('div');
                    recalledImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                    
                    const imageContainer = createAIImageWithDownload(data.recalledImage, 'Recalled Image', 'recalled-image');
                    recalledImageDiv.appendChild(imageContainer);
                    
                    lastMessage.appendChild(recalledImageDiv);
                  }
                  
                  // Store the message in conversation history (don't duplicate the image)
                  const assistantMessage = { 
                    role: 'assistant', 
                    content: data.response
                  };
                  
                  // Check for duplicates
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                } else if (data.requestedImage) {
                  // If an image was requested for display, show it
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Then add the requested image to the last assistant message
                  const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                  if (lastMessage) {
                    const requestedImageDiv = document.createElement('div');
                    requestedImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                    
                    const imageContainer = createAIImageWithDownload(data.requestedImage, 'Requested Image', 'requested-image');
                    requestedImageDiv.appendChild(imageContainer);
                    
                    lastMessage.appendChild(requestedImageDiv);
                  }
                  
                  // Store the message in conversation history (don't duplicate the image)
                  const assistantMessage = { 
                    role: 'assistant', 
                    content: data.response
                  };
                  
                  // Check for duplicates
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                } else {
                  addMessage('assistant', data.response);
                  const assistantMessage = { role: 'assistant', content: data.response };
                  
                  // Check for duplicates
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                }
              }
            })
            .catch(error => {
              removeTypingIndicator(typingId);
              addMessage('assistant', 'Sorry, I encountered an error. Please try again.');
              console.error('Error:', error);
            })
            .finally(() => {
              sendBtn.disabled = false;
              chatInput.disabled = false;
              fileInput.disabled = false;
              chatInput.focus();
            });
          } else {
            // Send text only - also include conversation history for context
            // Check if the last message is the same (avoid duplicates)
            const userMessage = { 
              role: 'user', 
              content: message 
            };
            const lastMessage = conversationHistory[conversationHistory.length - 1];
            const isDuplicate = lastMessage && 
              lastMessage.role === 'user' && 
              JSON.stringify(lastMessage.content) === JSON.stringify(userMessage.content);
            
            if (!isDuplicate) {
              conversationHistory.push(userMessage);
            }
            
        // Determine message type based on user input
        const messageLower = message.toLowerCase();
        let messageType = 'general';
        if (messageLower.includes('generate') || messageLower.includes('create an image') || messageLower.includes('make an image') || messageLower.includes('draw') || messageLower.includes('show me an image of')) {
          messageType = 'generating';
        } else if (messageLower.includes('stage') || messageLower.includes('design') || messageLower.includes('furniture') || messageLower.includes('decorate')) {
          messageType = 'staging';
        } else if (messageLower.includes('describe') || messageLower.includes('analyze') || messageLower.includes('look at') || messageLower.includes('show me') || (messageLower.includes('image') && (messageLower.includes('how') || messageLower.includes('what')))) {
          messageType = 'analyzing';
        }
        
        // Show typing indicator
        const typingId = showTypingIndicator(messageType);
            
            // Get userId from localStorage
            const userId = localStorage.getItem('userId');
            
            fetch('/api/chat', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                messages: conversationHistory,
                userId: userId,
                model: window.getSelectedModelApiName ? window.getSelectedModelApiName() : 'gpt-4o-mini'
              }),
            })
            .then(response => response.json())
            .then(data => {
              removeTypingIndicator(typingId);
              
              if (data.error) {
                addMessage('assistant', 'Sorry, I encountered an error: ' + data.error);
              } else if (data.contextLimitReached) {
                // Context limit reached - show message and don't add to history
                addMessage('assistant', data.response);
              } else {
                // If staging was processed, display the staged image
                // Handle staged images (single or array)
                const stagedImages = data.stagedImages || (data.stagedImage ? [data.stagedImage] : []);
                if (stagedImages.length > 0) {
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Then add the staged image(s) to the last assistant message
                  const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                  if (lastMessage) {
                    stagedImages.forEach((stagedImage, index) => {
                      const stagedImageDiv = document.createElement('div');
                      stagedImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                      
                      const imageContainer = createAIImageWithDownload(stagedImage, `Staged Room ${stagedImages.length > 1 ? `(${index + 1})` : ''}`, `staged-room-${index}`);
                      stagedImageDiv.appendChild(imageContainer);
                      
                      lastMessage.appendChild(stagedImageDiv);
                    });
                  }
                  
                  // Store staged image(s) in conversation history
                  const contentItems = [{ type: 'text', text: data.response }];
                  stagedImages.forEach((stagedImage) => {
                    contentItems.push({ 
                      type: 'image_url', 
                      image_url: { url: stagedImage },
                      isStaged: true
                    });
                  });
                  
                  const assistantMessage = { 
                    role: 'assistant', 
                    content: contentItems
                  };
                  
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                } else if (data.generatedImages || data.generatedImage) {
                  // Handle generated images (single or array)
                  const generatedImages = data.generatedImages || (data.generatedImage ? [data.generatedImage] : []);
                  
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Then add the generated image(s) to the last assistant message
                  const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                  if (lastMessage) {
                    generatedImages.forEach((generatedImage, index) => {
                      const generatedImageDiv = document.createElement('div');
                      generatedImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                      
                      const imageContainer = createAIImageWithDownload(generatedImage, `Generated Image ${generatedImages.length > 1 ? `(${index + 1})` : ''}`, `generated-image-${index}`);
                      generatedImageDiv.appendChild(imageContainer);
                      
                      lastMessage.appendChild(generatedImageDiv);
                    });
                  }
                  
                  // Store generated image(s) in conversation history
                  const contentItems = [{ type: 'text', text: data.response }];
                  generatedImages.forEach((generatedImage) => {
                    contentItems.push({ 
                      type: 'image_url', 
                      image_url: { url: generatedImage },
                      isGenerated: true
                    });
                  });
                  
                  const assistantMessage = { 
                    role: 'assistant', 
                    content: contentItems
                  };
                  
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                } else if (data.cadImage || (data.cadImages && data.cadImages.length > 0)) {
                  // If CAD processing was done, display the CAD image(s)
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Normalize to array
                  const cadImages = data.cadImages || (data.cadImage ? [data.cadImage] : []);
                  
                  if (cadImages.length > 0) {
                    // Then add the CAD image(s) to the last assistant message
                    const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                    if (lastMessage) {
                      cadImages.forEach((cadImage, index) => {
                        const cadImageDiv = document.createElement('div');
                        cadImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                        
                        const imageTitle = cadImages.length > 1 ? `3D Render from Blueprint (${index + 1})` : '3D Render from Blueprint';
                        const imageContainer = createAIImageWithDownload(cadImage, imageTitle, `cad-render-${index}`);
                        cadImageDiv.appendChild(imageContainer);
                        
                        lastMessage.appendChild(cadImageDiv);
                      });
                    }
                    
                    // Store CAD image(s) in conversation history
                    const cadAnnotation2 = data.cadImageAnnotation || null;
                    const cadAnnotations2 = data.cadImageAnnotations || {};
                    const cadAssistantMessage = { 
                      role: 'assistant', 
                      content: [
                        { type: 'text', text: data.response },
                        ...cadImages.map((cadImage, index) => ({
                          type: 'image_url', 
                          image_url: { url: cadImage },
                          isGenerated: true,
                          _annotation: cadImages.length === 1 ? cadAnnotation2 : (cadAnnotations2[`cad_${index}`] || null) // Store annotation for backend context building
                        }))
                      ]
                    };
                  
                  const lastMsg2 = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate2 = lastMsg2 && 
                    lastMsg2.role === 'assistant' && 
                    JSON.stringify(lastMsg2.content) === JSON.stringify(cadAssistantMessage.content);
                  
                  if (!isDuplicate2) {
                    conversationHistory.push(cadAssistantMessage);
                  }
                  }
                } else if (data.requestedImage) {
                  // If an image was requested for display, show it
                  // Add the AI response text first
                  addMessage('assistant', data.response);
                  
                  // Then add the requested image to the last assistant message
                  const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                  if (lastMessage) {
                    const requestedImageDiv = document.createElement('div');
                    requestedImageDiv.style.cssText = 'margin-top: 12px; text-align: left;';
                    
                    const imageContainer = createAIImageWithDownload(data.requestedImage, 'Requested Image', 'requested-image');
                    requestedImageDiv.appendChild(imageContainer);
                    
                    lastMessage.appendChild(requestedImageDiv);
                  }
                  
                  // Store the message in conversation history (don't duplicate the image)
                  const assistantMessage = { 
                    role: 'assistant', 
                    content: data.response
                  };
                  
                  // Check for duplicates
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                } else {
                  addMessage('assistant', data.response);
                  const assistantMessage = { role: 'assistant', content: data.response };
                  
                  // Check for duplicates
                  const lastMsg = conversationHistory[conversationHistory.length - 1];
                  const isDuplicate = lastMsg && 
                    lastMsg.role === 'assistant' && 
                    JSON.stringify(lastMsg.content) === JSON.stringify(assistantMessage.content);
                  
                  if (!isDuplicate) {
                    conversationHistory.push(assistantMessage);
                  }
                }
              }
            })
            .catch(error => {
              removeTypingIndicator(typingId);
              addMessage('assistant', 'Sorry, I encountered an error. Please try again.');
              console.error('Error:', error);
            })
            .finally(() => {
              isProcessing = false;
              updateSendButtonState();
              chatInput.focus();
            });
          }
        });
      }
      
      // Update send button state based on input and whether we're processing
      function updateSendButtonState() {
        const hasContent = chatInput.value.trim() || selectedFiles.length > 0;
        sendBtn.disabled = !hasContent || isProcessing;
      }
      
      // Update send button when input changes
      chatInput.addEventListener('input', function() {
        if (!isProcessing) {
          updateSendButtonState();
        }
      });
      
      // Update send button when files are added/removed
      const originalUpdateFilePreview = updateFilePreview;
      updateFilePreview = function() {
        originalUpdateFilePreview();
        if (!isProcessing) {
          updateSendButtonState();
        }
      };
      
      // Initialize send button state
      updateSendButtonState();
      
      function addMessage(role, content, files = null) {
        // Remove empty state if present
        const emptyState = chatMessages.querySelector('.empty-state');
        if (emptyState) {
          emptyState.remove();
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${role}`;
        
        const avatar = document.createElement('div');
        avatar.className = 'message-avatar';
        if (role === 'user') {
          const userImg = document.createElement('img');
          userImg.src = 'media-webp/User.webp';
          userImg.alt = 'User';
          avatar.appendChild(userImg);
        } else {
          const logoImg = document.createElement('img');
          logoImg.src = 'media-webp/logo/Logo64x64.webp';
          logoImg.alt = 'Stagify';
          avatar.appendChild(logoImg);
        }
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        
        // Add text content with formatting
        const textDiv = document.createElement('div');
        if (role === 'assistant') {
          // Format markdown for AI messages
          textDiv.innerHTML = formatMarkdown(content);
        } else {
          textDiv.textContent = content;
        }
        contentDiv.appendChild(textDiv);
        
        // Add files if present
        if (files) {
          const filesArray = Array.isArray(files) ? files : [files];
          filesArray.forEach(file => {
            if (file && file.name) {
              const fileDiv = document.createElement('div');
              fileDiv.className = 'message-file';
              fileDiv.style.cssText = 'margin-top: 8px; padding: 8px 0 8px 8px; background: rgba(0,0,0,0.05); border-radius: 6px; box-sizing: border-box;';
              
              if (file.type && file.type.startsWith('image/')) {
                const img = document.createElement('img');
                const imageSrc = URL.createObjectURL(file);
                img.src = imageSrc;
                img.alt = file.name;
                img.style.cssText = 'max-width: 100%; max-width: min(300px, 100%); max-height: 300px; border-radius: 4px; width: auto; height: auto; box-sizing: border-box; display: block; margin: 0; padding: 0; cursor: pointer; transition: opacity 0.2s, transform 0.2s;';
                img.addEventListener('click', () => openImageModal(imageSrc));
                fileDiv.appendChild(img);
              } else {
                const fileInfo = document.createElement('div');
                fileInfo.textContent = `📄 ${file.name}`;
                fileDiv.appendChild(fileInfo);
              }
              
              contentDiv.appendChild(fileDiv);
            }
          });
        }
        
        messageDiv.appendChild(avatar);
        messageDiv.appendChild(contentDiv);
        chatMessages.appendChild(messageDiv);
        
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      function showTypingIndicator(messageType = 'general') {
        // Remove any existing typing indicator first
        const existingIndicator = document.getElementById('typing-indicator');
        if (existingIndicator) {
          removeTypingIndicator('typing-indicator');
        }
        
        const typingDiv = document.createElement('div');
        typingDiv.className = 'message assistant';
        typingDiv.id = 'typing-indicator';
        
        const avatar = document.createElement('div');
        avatar.className = 'message-avatar';
        const logoImg = document.createElement('img');
        logoImg.src = 'media-webp/logo/Logo64x64.webp';
        logoImg.alt = 'Stagify';
        avatar.appendChild(logoImg);
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        
        const typing = document.createElement('div');
        typing.className = 'typing-indicator';
        
        // Messages based on type
        let messages = [];
        if (messageType === 'generating') {
          messages = [
            'generating image...',
            'creating your image...',
            'bringing your vision to life...',
            'crafting the details...',
            'rendering...',
            'almost there...',
            'finalizing details...',
            'polishing the result...',
            'just a moment...'
          ];
        } else if (messageType === 'staging') {
          messages = [
            'staging your room...',
            'adding furniture...',
            'selecting decor...',
            'arranging elements...',
            'applying styles...',
            'creating the design...',
            'generating the layout...',
            'refining details...',
            'almost ready...'
          ];
        } else if (messageType === 'analyzing') {
          messages = [
            'analyzing image...',
            'examining details...',
            'identifying elements...',
            'processing visual data...',
            'understanding the space...',
            'reviewing composition...',
            'studying the layout...',
            'almost done...'
          ];
        } else if (messageType === 'welcome') {
          messages = [
            'preparing your welcome...',
            'getting ready for you...',
            'setting things up...',
            'preparing a warm welcome...',
            'getting everything ready for you...',
            'almost ready to greet you...',
            'setting up your space...',
            'preparing something special...',
          ];
        } else {
          messages = [
            'thinking...',
            'processing your request...',
            'analyzing...',
            'considering options...',
            'working on it...',
            'almost there...',
            'just a moment...',
            'preparing response...'
          ];
        }
        
        // Start with a random message
        let currentIndex = Math.floor(Math.random() * messages.length);
        typing.textContent = messages[currentIndex];
        
        // Rotate messages randomly every 1.5 seconds (avoiding immediate repetition)
        const messageInterval = setInterval(() => {
          let nextIndex;
          do {
            nextIndex = Math.floor(Math.random() * messages.length);
          } while (nextIndex === currentIndex && messages.length > 1);
          currentIndex = nextIndex;
          typing.textContent = messages[currentIndex];
        }, 1500);
        
        // Store interval ID so we can clear it later
        typingDiv.dataset.intervalId = messageInterval;
        
        contentDiv.appendChild(typing);
        typingDiv.appendChild(avatar);
        typingDiv.appendChild(contentDiv);
        chatMessages.appendChild(typingDiv);
        
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        return 'typing-indicator';
      }
      
      function removeTypingIndicator(id) {
        const indicator = document.getElementById(id);
        if (indicator) {
          // Clear the message rotation interval
          if (indicator.dataset.intervalId) {
            clearInterval(parseInt(indicator.dataset.intervalId));
          }
          indicator.remove();
        }
      }
      
      // Image modal functions
      function openImageModal(imageSrc) {
        const modal = document.getElementById('image-modal');
        const modalImg = document.getElementById('image-modal-img');
        if (modal && modalImg) {
          modalImg.src = imageSrc;
          modal.classList.add('active');
          document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }
      }
      
      function closeImageModal() {
        const modal = document.getElementById('image-modal');
        if (modal) {
          modal.classList.remove('active');
          document.body.style.overflow = ''; // Restore scrolling
        }
      }
      
      // Download image function
      function downloadImage(imageSrc, filename = 'image') {
        // Convert base64 data URL to blob
        fetch(imageSrc)
          .then(res => res.blob())
          .then(blob => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'image.png';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
          })
          .catch(error => {
            console.error('Error downloading image:', error);
            // Fallback: try direct download for data URLs
            try {
              const a = document.createElement('a');
              a.href = imageSrc;
              a.download = filename || 'image.png';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
            } catch (e) {
              console.error('Fallback download also failed:', e);
            }
          });
      }
      
      // Helper function to create AI image with download button
      function createAIImageWithDownload(imageSrc, altText, imageType = 'image') {
        const container = document.createElement('div');
        container.className = 'ai-image-container';
        
        const img = document.createElement('img');
        img.src = imageSrc;
        img.alt = altText;
        img.className = 'ai-generated-image';
        img.addEventListener('click', () => openImageModal(imageSrc));
        
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'ai-image-download-btn';
        downloadBtn.title = 'Download image';
        downloadBtn.setAttribute('aria-label', 'Download image');
        
        const downloadIcon = document.createElement('img');
        downloadIcon.src = 'media-webp/download.webp';
        downloadIcon.alt = 'Download';
        downloadBtn.appendChild(downloadIcon);
        downloadBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Prevent opening modal when clicking download
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
          const extension = imageSrc.includes('data:image/png') ? 'png' : 
                          imageSrc.includes('data:image/jpeg') || imageSrc.includes('data:image/jpg') ? 'jpg' : 
                          imageSrc.includes('data:image/webp') ? 'webp' : 'png';
          const filename = `${imageType}-${timestamp}.${extension}`;
          downloadImage(imageSrc, filename);
        });
        
        container.appendChild(img);
        container.appendChild(downloadBtn);
        
        return container;
      }
    </script>
    
    <!-- Image Modal/Lightbox -->
    <div id="image-modal" class="image-modal">
      <span id="image-modal-close" class="image-modal-close">&times;</span>
      <img id="image-modal-img" class="image-modal-content" src="" alt="Enlarged image">
    </div>
    
    <script>
      // Model selector dropdown functionality
      (function initModelSelector() {
        const modelSelector = document.querySelector('.model-selector');
        const modelSelectorBtn = document.getElementById('model-selector-btn');
        const modelDropdown = document.getElementById('model-dropdown');
        const modelOptions = document.querySelectorAll('.model-option');
        
        // Get saved model key from localStorage or default to "fast"
        function getSelectedModelKey() {
          return localStorage.getItem('selectedModel') || 'fast';
        }
        
        // Save model key to localStorage
        function setSelectedModelKey(modelKey) {
          localStorage.setItem('selectedModel', modelKey);
        }
        
        // Map model key to API model name
        function getModelApiName(modelKey) {
          const modelMap = {
            'fast': 'gpt-4o-mini',
            'pro': 'gpt-5-mini'
          };
          return modelMap[modelKey] || 'gpt-4o-mini';
        }
        
        // Get translated text for model
        function getModelText(modelKey) {
          if (window.LanguageSystem && window.LanguageSystem.isLoaded()) {
            const translationKey = modelKey === 'fast' ? 'pdf.modelSelector.fast' : 'pdf.modelSelector.pro';
            return window.LanguageSystem.getText(translationKey) || (modelKey === 'fast' ? 'Fast' : 'Pro');
          }
          return modelKey === 'fast' ? 'Fast' : 'Pro';
        }
        
        // Update the displayed model text
        function updateModelDisplay() {
          const savedModelKey = getSelectedModelKey();
          const modelText = modelSelectorBtn?.querySelector('.model-selector-text');
          if (modelText) {
            modelText.textContent = getModelText(savedModelKey);
          }
        }
        
        // Initialize display from localStorage
        // Wait for language system to be ready
        function waitForLanguageSystem() {
          if (window.LanguageSystem && window.LanguageSystem.isLoaded()) {
            updateModelDisplay();
          } else {
            // Try again after a short delay
            setTimeout(waitForLanguageSystem, 100);
          }
        }
        waitForLanguageSystem();
        
        // Update display when language changes
        // Method 1: Hook into applyLanguageToElements
        if (window.LanguageSystem) {
          const originalApplyLanguage = window.LanguageSystem.applyLanguageToElements;
          if (originalApplyLanguage) {
            window.LanguageSystem.applyLanguageToElements = function() {
              originalApplyLanguage.call(this);
              // Small delay to ensure translations are applied first
              setTimeout(updateModelDisplay, 50);
            };
          }
        }
        
        // Method 2: Listen to language selector change event
        const languageSelect = document.getElementById('language-select');
        if (languageSelect) {
          languageSelect.addEventListener('change', () => {
            // Wait for language system to update translations
            setTimeout(updateModelDisplay, 200);
          });
        }
        
        // Method 3: Watch for language-loaded class on body
        const bodyObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              if (document.body.classList.contains('language-loaded')) {
                updateModelDisplay();
              }
            }
          });
        });
        bodyObserver.observe(document.body, {
          attributes: true,
          attributeFilter: ['class']
        });
        
        // Method 4: Poll for language changes (fallback)
        let lastLanguage = localStorage.getItem('selectedLanguage') || 'english';
        setInterval(() => {
          const currentLanguage = localStorage.getItem('selectedLanguage') || 'english';
          if (currentLanguage !== lastLanguage) {
            lastLanguage = currentLanguage;
            setTimeout(updateModelDisplay, 200);
          }
        }, 500);
        
        // Expose getModelApiName for use in fetch calls
        window.getSelectedModelApiName = function() {
          return getModelApiName(getSelectedModelKey());
        };
        
        if (modelSelectorBtn && modelDropdown) {
          // Toggle dropdown on button click
          modelSelectorBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            modelSelector.classList.toggle('open');
          });
          
          // Close dropdown when clicking outside
          document.addEventListener('click', (e) => {
            if (!modelSelector.contains(e.target)) {
              modelSelector.classList.remove('open');
            }
          });
          
          // Handle model option selection
          modelOptions.forEach(option => {
            option.addEventListener('click', (e) => {
              e.stopPropagation();
              const modelKey = option.getAttribute('data-model');
              if (modelKey) {
                setSelectedModelKey(modelKey);
                updateModelDisplay();
                modelSelector.classList.remove('open');
              }
            });
          });
        }
      })();
      
      // Initialize modal event listeners (run immediately since script is at end of body)
      (function initImageModal() {
        const modal = document.getElementById('image-modal');
        const closeBtn = document.getElementById('image-modal-close');
        
        if (modal) {
          // Close modal when clicking outside the image
          modal.addEventListener('click', function(e) {
            if (e.target === modal) {
              closeImageModal();
            }
          });
          
          // Close modal with Escape key
          document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && modal.classList.contains('active')) {
              closeImageModal();
            }
          });
        }
        
        if (closeBtn) {
          closeBtn.addEventListener('click', closeImageModal);
        }
      })();
    </script>
  </body>
</html>

